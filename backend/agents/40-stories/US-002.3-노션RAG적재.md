# 노션 페이지 RAG 적재 시나리오 사양서 (Persist Notion Pages into Chroma)
**문서 버전:** 1.0
**작성일:** 2025-10-07 18:00:00 KST

---

## 1) 개요
노션 워크스페이스에서 가져온 페이지 콘텐츠를 전처리하여 RAG(검색 증강 생성) 파이프라인에 투입하고, Chroma 벡터 저장소에 임베딩을 보존하는 시나리오를 정의합니다. `/notion/pages/pull` 엔드포인트가 노션 API에서 데이터를 수집한 뒤 JSONL 포맷으로 가공하고, Azure OpenAI 임베딩을 생성하여 워크스페이스 전용 Chroma 컬렉션에 저장하는 전체 흐름을 다룹니다.

---

## 2) 선행 조건
- 환경 변수 `AZURE_OPENAI_API_KEY`, `AZURE_OPENAI_ENDPOINT`, `AZURE_OPENAI_API_VERSION`, `AZURE_OPENAI_EMBEDDING_DEPLOYMENT`가 올바르게 설정돼 있어야 합니다.
- Chroma 데이터는 백엔드 컨테이너의 `backend/storage/workspace` 경로에 워크스페이스 단위로 보존됩니다.
- 노션 워크스페이스와 자격 증명이 이미 연결돼 있어 `/notion/pages/pull`이 페이지 내용을 가져올 수 있어야 합니다.

---

## 3) 주요 컴포넌트
- `backend/notions/ragTransform.py`: 노션 페이지 블록을 텍스트로 평탄화하고 JSONL 레코드 및 LangChain `Document`로 변환합니다.
- `backend/rag/chroma.py`: Azure OpenAI 임베딩을 사용해 워크스페이스별 Chroma 컬렉션에 청크를 저장합니다.
- `backend/routers/notion.py`: `/notion/pages/pull` 요청을 처리하고, 전처리 결과와 RAG 적재 결과(청크 수)를 응답과 로그에 기록합니다.

---

## 4) 상세 흐름
1. 클라이언트가 `/notion/pages/pull`을 호출하면 노션 API에서 페이지 및 블록 데이터를 가져옵니다.
2. `build_jsonl_records`가 각 페이지의 텍스트를 평탄화하여 `page_id`, `title`, `last_edited_time`, `text`, `page_url` 필드를 포함한 JSONL 레코드를 생성합니다. 텍스트가 없더라도 빈 문자열을 유지합니다.
3. JSONL 레코드를 LangChain `Document` 리스트로 변환하면서, 텍스트가 있는 레코드만 Azure OpenAI 임베딩 대상으로 준비합니다.
4. `ChromaRAGService.upsert_documents`가 임베딩을 계산하고 워크스페이스 ID로 네임스페이스화된 컬렉션에 저장합니다.
5. 응답에는 JSONL 문자열, 적재된 청크 수, 마지막 동기화 시각이 포함되며, 동일 내용을 Arcana 로거가 DEBUG 레벨로 기록합니다.

---

## 5) 예외 처리 및 롤백
- 임베딩 생성을 위한 필수 환경 변수가 누락되면 즉시 500 오류를 발생시키고 적재를 중단합니다.
- 노션 API 호출 실패 시 해당 오류를 클라이언트에 전달하고 RAG 적재를 수행하지 않습니다.
- Chroma 저장 중 오류가 발생하면 예외를 발생시키고, 부분적으로 저장된 청크는 Chroma 내부 일관성 규칙에 따라 처리됩니다.

---

## 6) 검증 포인트
- DEBUG 로그에 전처리된 JSONL 페이로드가 출력되는지 확인합니다.
- 페이지 텍스트가 비어 있어도 JSONL 레코드가 유지되는지 확인합니다.
- 워크스페이스별 Chroma 디렉터리에 임베딩 데이터가 생성되고, `chunk_count`가 응답으로 전달되는지 검증합니다.

---

## 7) 후속 과제
- 대용량 페이지를 위한 텍스트 청크 사이즈 자동 조절 및 요약 전략 도입.
- RAG 검색 API(`/rag/query`) 정의 및 프론트엔드와의 통합.
- 벡터 저장소 상태 모니터링 및 백업 전략 수립.
